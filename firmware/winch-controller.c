#include <pic12f1840.h>
#include <stdint.h>

static __code uint16_t __at (_CONFIG1) configword1 = _FOSC_INTOSC & _WDTE_OFF & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_OFF;
static __code uint16_t __at (_CONFIG2) configword2 = _WRT_OFF & _PLLEN_OFF & _STVREN_OFF & _LVP_OFF;


/*

Pin 7   RA0/ICSPDAT = High side left
Pin 6   RA1/ICSPCLK = High side right
Pin 5   RA2/CCP1  = Low side right (CCP1 for music!)
Pin 4   RA3/Vpp goes to ICSP
Pin 3   RA4 = Low side left
Pin 2   RA5/RX = Servo/UART Input

Music that the controller makes
===============================
- Startup sound
- Off to idle transition
- Idle to off transition


Playing a "song" through the motor
==================================

Single tones are generated by a PWM of 50% at the frequency of the sound.
A "song" comprises of individual notes, each note has a duration.
Between notes there can be pauses of a given duration.

Music notes go from 16.35 Hz to 4978.03 Hz according to
http://www.phy.mtu.edu/~suits/notefreqs.html
C3 to C5 (a smaller scale probably is enough) from 130.81 to 523.25 Hz
Maybe the best is to encode the musical note (there are 12 notes in an
octave) and have a table that has pre-calculated timer values for
the reqired frequency.

130.81 Hz (C3) -> 7645 us period = 3823 us half period
440 Hz (A4) -> 2273 us period = 1136 us half period
2093 Hz (C7) -> 478 us period = 239 us half period

If we allow for 4..1020 ms tone / pause durations (8 bits with 4ms resolution)
we need to decrement the "tone counter" every 4,096 ms. We can do that
reasonably accurate by accumulating an 8 bit value with a 16us resolution.
So at each interrupt we would add the number of "16us units" to our counter.
If it  overflows we decrement the tone counter. This way we should be able to
account for reasonably accurate tone durations regardless of the
note frequency.

If we use Timer1 for music we will not be able to output music at the
same time as measuring a servo pulse. This should not pose an issue
if the songs we play are short, and we can make the software stop while
the songs are playing.

We use Timer1 and CCP1 in compare mode. CCP1 is set-up to trigger
an interrupt on match and reset the counter. We toggle the output
in the interrup routine.

We run Timer1 with a 1 us clock. For every note we need the 16 bit compare
value. We need to also have the 16us based increment value, which
we can easily calculate out of the compare value (divide by 16 is ">> 4").

*/

#define MOTOR_OFF   0b00000000      // Motor ports are floating
#define MOTOR_BRAKE 0b00010100      // Motor ports are shorted for brake function
#define MOTOR_IN    0b00000101      // Direction for winching in
#define MOTOR_OUT   0b00010010      // Direction for winching out

// Enumeration for notes used in songs
#define C3 0
#define D3 1
#define E3 2
#define F3 3
#define G3 4
#define A3 5
#define B3 6
#define C4 7
#define D4 8
#define E4 9
#define F4 10
#define G4 11
#define A4 12
#define B4 13
#define C5 14
#define PAUSE 15
#define SONG_END 0xff

// Frequencies for each notes in Hz
// Source: http://www.phy.mtu.edu/~suits/notefreqs.html
#define F_C3 130.81
#define F_D3 146.83
#define F_E3 164.81
#define F_F3 174.61
#define F_G3 196.00
#define F_A3 220.00
#define F_B3 246.94
#define F_C4 261.63
#define F_D4 293.66
#define F_E4 329.63
#define F_F4 349.23
#define F_G4 392.00
#define F_A4 440.00
#define F_B4 493.88
#define F_C5 523.25

#define T_PAUSE 0xFFF   // Use 4096us as compare value for pause

#define SONG_STARTUP 0
#define SONG_ACTIVATE 1
#define SONG_DEACTIVATE 2
#define SONG_DUMMY_BRAKE 3

extern void Init_input(void);
extern void Read_input(void);

enum {
    WINCH_MODE_UNINITIALIZED = 0,
    WINCH_MODE_OFF = 0x80,
    WINCH_MODE_IDLE = 0x81,
    WINCH_MODE_IN = 0x82,
    WINCH_MODE_OUT = 0x83
} winch_mode = WINCH_MODE_UNINITIALIZED;

static unsigned char old_winch_mode = WINCH_MODE_UNINITIALIZED;
static volatile unsigned char note;
static volatile unsigned char duration;
static volatile unsigned char duration_increment;
static volatile unsigned char duration_counter;
static volatile unsigned char in_progress_flag;
static volatile unsigned char note_output_flag;


// Tables to look up the CCP1 compare values for a given note. High byte
// and low byte have a separate table for simplicity sake.
__code unsigned char notes_high[] = {
    ((unsigned int) (500000 / F_C3)) >> 8,
    ((unsigned int) (500000 / F_D3)) >> 8,
    ((unsigned int) (500000 / F_E3)) >> 8,
    ((unsigned int) (500000 / F_F3)) >> 8,
    ((unsigned int) (500000 / F_G3)) >> 8,
    ((unsigned int) (500000 / F_A3)) >> 8,
    ((unsigned int) (500000 / F_B3)) >> 8,
    ((unsigned int) (500000 / F_C4)) >> 8,
    ((unsigned int) (500000 / F_D4)) >> 8,
    ((unsigned int) (500000 / F_E4)) >> 8,
    ((unsigned int) (500000 / F_F4)) >> 8,
    ((unsigned int) (500000 / F_G4)) >> 8,
    ((unsigned int) (500000 / F_A4)) >> 8,
    ((unsigned int) (500000 / F_B4)) >> 8,
    ((unsigned int) (500000 / F_C5)) >> 8,
    ((unsigned int) T_PAUSE) >> 8
};

__code unsigned char notes_low[] = {
    ((unsigned int) (500000 / F_C3)),
    ((unsigned int) (500000 / F_D3)),
    ((unsigned int) (500000 / F_E3)),
    ((unsigned int) (500000 / F_F3)),
    ((unsigned int) (500000 / F_G3)),
    ((unsigned int) (500000 / F_A3)),
    ((unsigned int) (500000 / F_B3)),
    ((unsigned int) (500000 / F_C4)),
    ((unsigned int) (500000 / F_D4)),
    ((unsigned int) (500000 / F_E4)),
    ((unsigned int) (500000 / F_F4)),
    ((unsigned int) (500000 / F_G4)),
    ((unsigned int) (500000 / F_A4)),
    ((unsigned int) (500000 / F_B4)),
    ((unsigned int) (500000 / F_C5)),
    ((unsigned int) T_PAUSE)
};


__code unsigned char song_startup[] = {
    C4, 80000 / 4096,
    PAUSE, 40000 / 4096,
    F4, 80000 / 4096,
    PAUSE, 40000 / 4096,
    A4, 80000 / 4096,
    PAUSE, 40000 / 4096,
    C5, 160000 / 4096,
    PAUSE, 40000 / 4096,
    A4, 80000 / 4096,
    PAUSE, 40000 / 4096,
    C5, 240000 / 4096,
    SONG_END
};

__code unsigned char song_activate[] = {
    C4, 80000 / 4096,
    D4, 80000 / 4096,
    E4, 80000 / 4096,
    F4, 80000 / 4096,
    G4, 80000 / 4096,
    C4, 80000 / 4096,
    D4, 80000 / 4096,
    E4, 80000 / 4096,
    F4, 80000 / 4096,
    G4, 80000 / 4096,
    A4, 80000 / 4096,
    B4, 80000 / 4096,
    C5, 160000 / 4096,
    SONG_END
};

__code unsigned char song_deactivate[] = {
    C5, 80000 / 4096,
    B4, 80000 / 4096,
    A4, 80000 / 4096,
    G4, 80000 / 4096,
    F4, 80000 / 4096,
    C5, 80000 / 4096,
    B4, 80000 / 4096,
    A4, 80000 / 4096,
    G4, 80000 / 4096,
    F4, 80000 / 4096,
    E4, 80000 / 4096,
    D4, 80000 / 4096,
    C4, 240000 / 4096,
    SONG_END
};

// Not really a 'song', just a pause to prevent shoot-through before
// braking the winch
__code unsigned char song_dummy_brake[] = {
    PAUSE, 50000 / 4096,
    SONG_END
};

/*****************************************************************************
 Init_hardware()

 Initializes all used peripherals of the PIC chip.
 ****************************************************************************/
static void Init_hardware(void) {
    //-----------------------------
    // Clock initialization
    OSCCON = 0b01111010;    // 4x PLL disabled, 16 MHz HF, Internal oscillator

    //-----------------------------
    // IO Port initialization
    PORTA = 0;
    LATA = 0;
    ANSELA = 0;
    TRISA = 0b11101000;     // Make all ports that are not used for the motor input
    APFCON = 0b10000000;    // Use RA0/RA5 for UART TX/RX, CCP1 on RA2

    //-----------------------------
    // Initialize Timer1 for 1 MHz operation
    // Compare mode: special event trigger
    T1CON = 0b00100000;
    CCP1CON = 0b00001011;

    // Enable interrupts (though non specific is active at this point)
    PEIE = 1;
    GIE = 1;
}


/*****************************************************************************
 Play_song()

 Play a melody via the connected motor.
 This function only returns after the song has finished completely.

 A song is a sequence of notes and their duration. A special marker is used
 to signify a pause of a certain duration, another special marker indicates
 the end of the song. Songs are stored in ROM.
 ****************************************************************************/
void Play_song(unsigned char song) {
    const unsigned char *song_ptr;

    song_ptr = song_startup;
    if (song == SONG_ACTIVATE)
        song_ptr = song_activate;
    if (song == SONG_DEACTIVATE)
        song_ptr = song_deactivate;
    if (song == SONG_DUMMY_BRAKE)
        song_ptr = song_dummy_brake;

    // For each note in the song do ...
    while (*song_ptr != SONG_END) {
        // Load the note and its duration
        note = *song_ptr++;
        duration = *song_ptr++;

        // Retrive the on/off duration for the requested note
        CCPR1H = notes_high[note];
        CCPR1L = notes_low[note];

        // Calculate the 16 us units the on/off duration occupies so that
        // we can use the note frequency to time duration as well
        duration_increment =  (notes_high[note] << 4) + (notes_low[note] >> 4);

        // Start the Timer1 and enable the interrupt handing the frequency.
        in_progress_flag = 1;
        CCP1CON = 0b00001011;   // Compare mode: special event trigger
        CCP1IE = 1;
        TMR1ON = 1;

        // Wait until the interrupt completed playing the current note
        while (in_progress_flag != 0) {
            ; // wait ...
        }
    }
}


/*****************************************************************************
 Intr()

 Interrupt handler!

 The interrupt handler is triggered by CCP1 in special event mode.
 When the compare registers match the timer is reset and the interrupt is
 triggered.
 ****************************************************************************/
void Intr(void) __interrupt 0
{
    CCP1IF = 0;

    // Toggle the motor output unless we are dealing with a Pause
    // Note that we must turn the motor foward/backwards to stay at its current
    // position, otherwise it will spin in one direction
    // Note that we add motor-off inbetween to prevent MOSFET shoot-through.
    if (note != PAUSE) {
        ++note_output_flag;
        if ((note_output_flag & 0x03) == 0x01)
            LATA = MOTOR_IN;
        else if ((note_output_flag & 0x03) == 0x03)
            LATA = MOTOR_OUT;
        else
            LATA = MOTOR_OFF;
    }
    else {
        LATA = MOTOR_OFF;
    }

    // Add the time of the note on/off period in 16 us units to a counter.
    // If the counter overflows (16 us * 256 = 4.096 ms) decrement the
    // note duration. If the duration has reached zero we have finished
    // playing the note (or pause), so  we terminate further interrupts
    // and let the Play_song function know that we are finished.
    duration_counter += duration_increment;
    if (C != 0) {
        --duration;
        if (duration == 0) {
            LATA = MOTOR_OFF;
            CCP1IE = 0;
            TMR1ON = 0;
            in_progress_flag = 0;
        }
    }
}


/*****************************************************************************
 Process_winch()

 Turns the winch on/off depending on the requested winch mode, and play
 songs if needed.
 ****************************************************************************/
static void Process_winch(void) {
    if (winch_mode != old_winch_mode) {
        switch(winch_mode) {

        case WINCH_MODE_OFF:
            LATA = MOTOR_OFF;
            if (old_winch_mode != WINCH_MODE_UNINITIALIZED) {
                Play_song(SONG_DEACTIVATE);
            }
            break;

        case WINCH_MODE_IDLE:
            if (old_winch_mode == WINCH_MODE_OFF) {
                Play_song(SONG_ACTIVATE);
            }
            // Pause for a short time to prevent shoot-through in the MOSFETs,
            // then short-circuit the motor winding to brake electrically
            Play_song(SONG_DUMMY_BRAKE);
            LATA = MOTOR_BRAKE;
            break;

        case WINCH_MODE_IN:
            LATA = MOTOR_IN;
            break;

        case WINCH_MODE_OUT:
            LATA = MOTOR_OUT;
            break;

        default:
            LATA = MOTOR_OFF;
            break;
        }

        old_winch_mode = winch_mode;
    }
}


/*****************************************************************************
 main()

 No introduction needed ...
 ****************************************************************************/
void main(void) {
    Init_hardware();
    Init_input();

    // In order to not draw power straight away after power-on we delay
    // execution for 3 rounds of Read_input().
    // This was originally designed for the UART reader, where the UART
    // sender would send out commands once a second.
    // Other readers need to implement a delay function in their Read_input()
    // to achieve similar timings. WINCH_MODE_UNINITIALIZED could be used
    // to determine whether such delay is necessary.
    for (duration_counter = 0; duration_counter < 3 ; ++duration_counter) {
        Read_input();
    }

    Play_song(SONG_STARTUP);

    while (1) {
        Read_input();
        Process_winch();
    }
}

